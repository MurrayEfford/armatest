---
title: '**ipsecr** 1.0 - spatially explicit capture--recapture by inverse prediction'
author: "Murray Efford"
date: "`r Sys.Date()`"
output: 
  pdf_document: 
    toc: yes
    toc_depth: 2
vignette: > 
  %\VignetteIndexEntry{Spatially explicit capture--recapture by inverse prediction}
  \usepackage[utf8]{inputenc}
  %\VignetteEngine{knitr::rmarkdown}
header-includes: 
   - \renewcommand{\vec}[1]{\mathbf{#1}}
---

\vspace{12pt}

This document provides an overview of **ipsecr** 1.0, an R package for spatially explicit capture--recapture analysis (SECR) that uses simulation and inverse prediction instead of maximum likelihood, as in **secr** (Efford 2022), or MCMC, as in various Bayesian approaches. The parent package **secr** included the function `ip.secr`; **ipsecr** extends the capability of that function in its central function `ipsecr.fit` whose arguments are closely modelled on `secr.fit` from **secr**. 

Simulation and inverse prediction allows some models to be fitted that strictly cannot be fitted by other methods. Single-catch traps provide a the commonest example.

There are limitations: **ipsecr** 1.0 is limited to single-session data and does not yet allow variation in detection parameters (e.g., $\lambda_0$, $\sigma$).

# Inverse prediction for capture--recapture estimation

The method (Efford 2004; Efford, Dawson and Robbins 2004; see also Carothers 1979 and Pledger and Efford 1998) uses a vector-valued function of the raw data that provides a proxy for each coefficient (beta parameter) in the capture--recapture model. Each proxy is assumed to be monotonically related to the corresponding coefficient. 

We use $\vec x_p$ for the vector of known parameter values at which simulations are performed and $\vec y_p$ for the vectors of proxies computed from these simulated data. The method fits a multivariate multiple regression over a set of points in parameter space ('box') and inverts that regression to estimate parameter values $\vec x$ from the observed proxy vector $\vec y$.

The default proxy function `proxyfn1` works for simple models with constant density and two detection parameters.

The algorithm includes these steps

1. Compute proxy function from data
2. Simulate data for parameters at the vertices* of a box around plausible estimates
3. Compute proxy function for each simulation to generate predictor matrix 
4. Fit a multivariate multiple regression model with proxies at each vertex as the dependent variable
5. Invert regression model to estimate vector of parameters from the data proxies (1)
6. If the estimated parameters do not all lie inside box, adjust the box and repeat from (2)
7. Simulate at the estimates to obtain variance-covariance matrix 

\* including some centre points

# Simple example

This example uses a simulated single-catch trap dataset in **secr** that is loaded automatically when **ipsecr** is loaded. See [here](https://www.otago.ac.nz/density/pdfs/secr-datainput.pdf) for instructions on reading actual data.

```{r setup, message = FALSE, results = 'hide'}
library(ipsecr)
setNumThreads(2)   # adjust to number of available cores
```

```{r retrieve, eval = TRUE, echo = FALSE}
# previously...
# 
# setwd('../ipsecr/inst/example')
# saveRDS(ip.single,   'ip.single.RDS')
# saveRDS(ip.single.0, 'ip.single.0.RDS')
# saveRDS(ip.multi,    'ip.multi.RDS')
# saveRDS(secr.multi,  'secr.multi.RDS')
# saveRDS(ipx,         'ipx.RDS')

# retrieve saved fits from example folder to save time
ip.single   <- readRDS(system.file("example", "ip.single.RDS", package = "ipsecr"))
ip.single.0 <- readRDS(system.file("example", "ip.single.0.RDS", package = "ipsecr"))
ip.multi    <- readRDS(system.file("example", "ip.multi.RDS", package = "ipsecr"))
secr.multi  <- readRDS(system.file("example", "secr.multi.RDS", package = "ipsecr"))
ipx         <- readRDS(system.file("example", "ipx.RDS", package = "ipsecr"))
```


```{r examplefit, eval = FALSE}
ip.single <- ipsecr.fit(captdata, buffer = 100, detectfn = 'HHN')
```

The fitted model is of class 'ipsecr' for which there are the usual methods matching those in **secr** (`print`, `coef`, `predict`, `summary` etc.) as detailed [below](#methods)).

```{r output}
predict(ip.single)
```

# Proxy functions

The proxy function takes an **secr** capthist object as its first argument. It returns a vector of surrogate values, one for each coefficient (beta parameter) in the model. Two alternatives are provided, `proxyfn0` and `proxyfn1` (the default). For example,

```{r exampleproxy}
proxyfn0(captdata)
proxyfn1(captdata)
```

Users are free to define their own proxyfn, and this is necessary when the model involves additional coefficients (beta parameters) as in the density trend example below.

Changing the proxy function may have little effect on the estimates:


```{r compareproxy0, eval = FALSE}
ip.single.0 <- ipsecr.fit(captdata, buffer = 100, detectfn = 'HHN', proxyfn = proxyfn0, 
  trace = FALSE)
```

```{r compareproxy1}
# secr function 'collate' works for both secr and ipsecr fits 
collate(ip.single, ip.single.0)[1,,,]
```

# Comparing multi- and single-catch fits

**secr** fits a ML multi-catch model to data from single-catch traps. It is interesting to compare the MLE from **secr** with those from **ipsecr** which can switch between single- and multi-catch models.

```{r examplemulti, eval = FALSE}
secr.multi <- secr.fit(captdata, buffer = 100, detectfn = 'HHN', trace = FALSE)
ip.multi <- ipsecr.fit(captdata, buffer = 100, detectfn = 'HHN', trace = FALSE,
  details = list(newdetector = 'multi'))
```

The results are as expected: inverse prediction gives very similar estimates to ML for the multi-catch model, and both differ from the inverse prediction single-catch model with respect to the estimate of the detection parameter lambda0.

```{r compare}
collate(ip.single, ip.multi, secr.multi)[1,,,]
```

```{r examplecapped, eval = FALSE, echo = FALSE, cache = TRUE}
# Analyse as 'capped'
ip.capped <- ipsecr.fit(captdata, detectfn = 'HHN', details = list(newdetector = 'capped'), 
  trace = FALSE)
secr.capped <- secr.fit(captdata, detectfn = 'HHN', details = list(newdetector = 'capped'), 
  trace = FALSE)
```

```{r sparse, eval = FALSE, echo = FALSE}
# Test with sparse data
library(ipsecr)
set.seed(123)
grid <- make.grid(6,6, detector = 'single')
ch <- sim.capthist(grid, popn=list(D=1, buffer=100),detectfn='HHN', noccasions = 4, 
    detectpar = list(lambda0 = 0.1, sigma = 20))
summary(ch)
fit <- ipsecr.fit(ch, detectfn = 'HHN', start = list(D = 0.8, lambda0 = 0.15, sigma = 15),
    details = list(max.nsim = 1000, devmax= 0.05), ncores = 1)
summary(fit)
```

# Non-target interference

The data for single-catch and capped detectors may include a matrix indicating detectors that were disturbed or occupied by non-target species. We illustrate this by simulating disturbance at about 50% of the 235 unoccupied traps in the 'captdata' dataset. (This is an ad hoc method for generating demonstration data only).

```{r nontargetdata}
set.seed(123)
ch <- captdata
attr(ch, 'nontarget') <- (1-t(apply(ch,2:3,sum))) * (runif(500)>0.5)
summary(ch)$nontarget
```

The attribute 'nontarget' is a matrix with one row per trap and one column per occasion. Entries are either 1 (nontarget or disturbed) or 0 (target species or undisturbed). The model for a dataset including non-target data will include the additional parameter 'lambdak' (override by setting the details argument 'ignorenontarget = TRUE')

```{r nontargetdemo, eval = FALSE}
ip.single.nontarget <- ipsecr.fit(ch, detectfn = 'HHN', proxyfn = proxyfn2)
```

```{r readnontarget, echo = FALSE, eval = TRUE}
# previously...
# setwd('../ipsecr/inst/example')
# saveRDS(ip.single.nontarget, 'ip.single.nontarget.RDS')
ip.single.nontarget <- readRDS(system.file("example", "ip.single.nontarget.RDS", 
  package = "ipsecr"))
```

The new parameter 'lambdak' is the hazard for a disturbance process competing for detectors with the capture process. Not that the estimate of lambda0 has risen compared to ip.single.
```{r nontargetdemoresults}
predict(ip.single.nontarget)
```

# Tuning the algorithm

Performance of the inverse prediction algorithm depends on several components of the 'details' argument of `ipsecr.fit` that may be seen as tuning parameters. 

By default, the size of the box in parameter space is set to Â± 'boxsize' units on the link scale. This may be changed to a multiple of the central value with `boxtype = 'relative'`.

It is usual to start with a wide box and to use a narrower box for subsequent simulations, on the assumption that the first box has selected a region of parameter space very close to the solution.

The stopping criterion 'devmax' is used to exit the simulation loop early when sufficient precision has been achieved for all parameters. If `boxtype = 'absolute'` then the criterion is the standard error on the link scale. If `boxtype = 'relative'` then the criterion is the relative standard error (RSE or CV) on the link scale.

| Tuning parameter | Default | Description |
|--------------|--------- |----------------------------------|
| boxtype      | 'absolute' | 'absolute' or 'relative'  |
| boxsize     | 0.2 | size of first box | 
| boxsize2     | 0.05 | boxsize for boxes after the first | 
| centre       | 3 | number of centre points |
| devmax       | 0.002 | stopping criterion | 
| min.nsim     | 20 | minimum number of simulations per vertex |
| max.nsim     | 2000 | maximum number of simulations per vertex | 
| max.nbox     | 5 |  maximum number of boxes | 
| max.ntries   | 2 |  maximum number of attempts to achieve valid simulation |
| var.nsim     | 2000 | number of simulations for variance-covariance matrix |

# Fitting a density gradient

Distiller and Borchers (2015) simulated an example with a gradient in population density to demonstrate their method for data from single-catch traps when the time of each capture is known. Inverse prediction may be used to estimate density from these data, but assuming a constant density can result in bias. Here we illustrate a strategy for fitting the density gradient with inverse prediction. This requires an expanded proxy function that includes a proxy for the density gradient. As the function is a function of the capture histories alone we must use a gradient over detectors to stand for a gradient over points on the habitat mask. 

First simulate some data with an east-west gradient in density.

```{r simch, eval = TRUE}
# define covariate 'x0' for both traps and mask
tr <- traps(captdata)
covariates(tr) <- data.frame(x0 = tr$x/100)
mask <- make.mask(tr)
covariates(mask) <- data.frame(x0 = mask$x/100, D = (mask$x-265)/20)
set.seed(1237)
pop <- sim.popn(D = 'D', core = mask, model2D = 'IHP', buffer = 100)
ch <- sim.capthist(tr, popn = pop, detectfn = 'HHN', noccasions = 5, 
  detectpar = list(lambda0 = 0.2, sigma = 25))
# show east-west trend
table(tr[trap(ch),'x'])
```

A new proxy function is defined that uses the x-coordinate of the trap: 

```{r Dsurfacefit, eval = FALSE}
# note need to reference secr:: functions explicitly 
proxy.x <- function (capthist, ...) {
    n <- nrow(capthist)         ## number of individuals
    ch <- abs(capthist)>0
    nocc <- ncol(capthist)      ## number of occasions
    ni <- apply(ch, 2, sum)     ## individuals on each occasion
    estimates <- c(n, sum(ni)/n/nocc)
    # proxy for x-gradient
    trps <- secr::traps(capthist)
    x <- secr::covariates(trps)[secr::trap(capthist, names = FALSE),, drop = FALSE ]$x0
    dxy <- density(x, n = 64, cut = 0, from = min(x), to = max(x))
    fitx <- coef(lm(log(y)~x, data=dxy[c('x','y')]))
    rpsv <- secr::RPSV(capthist, CC = TRUE)
    c(log(estimates[1]), fitx[2], estimates[2], rpsv)
}
ipx <- ipsecr.fit(ch, mask = mask, detectfn = 'HHN', model = list(D~x0), proxyfn = proxy.x)
```

```{r Dsurfaceoutput, eval = TRUE}
coef(ipx)
predict(ipx)
plot(predictDsurface(ipx))
plot(tr, add = TRUE)
plotMaskEdge(ipx$mask, add=T)
```

The fitted relationship is linear on the log scale, whereas it was simulated as linear on the natural scale.

```{r fitx0, fig.width = 6, fig.height = 4}
par(mar = c(4,6,4,4))
xval <- seq(270,730,10)
pred <- predict(ipx, newdata = data.frame(x0 = xval/100))
plot(0,0, type='n', xlim= c(270,730), ylim = c(0,40), xlab = 'x', ylab = 'Density')
lines(xval, sapply(pred, '[', 'D','estimate'), col = 'red', lwd=2)
abline(-265/20,0.05)
rug(unique(tr$x))   # trap locations
```

To better match the original it would be possible to use an identity link for D.

# Fractional designs

The package **FrF2** may be used for fractional factorial designs (Groemping, 2014). Fractional designs are probably useful only when parameters are numerous.

Fractional designs are selected by setting `details = list(factorial = 'fractional')` in `ipsecr.fit`. 
```{r, eval = FALSE}
ipsecr.fit(captdata, details = list(factorial = 'fractional'))
```

The default is a 1/2 factorial design, illustrated by this code:
```{r fractional, eval = FALSE, message = FALSE}
library(FrF2)
NP <- 3
boxsize <- rep(0.2,3)
design <- FrF2(2^(NP-1),NP, factor.names = c('D','lambda0','sigma'), ncenter = 2)
data.frame(design)
# recast factors as numeric
design <- sapply(design, function(x) as.numeric(as.character(x)))
design <- sweep(design, MAR=2, STATS = boxsize, FUN='*')
design
# apply to beta
beta <- log(c(5,0.2,25))
designbeta <- sweep(design, MAR=2, STATS=beta, FUN='+')
designbeta 
```

For other designs you may specify the desired arguments of FrF2 as a list e.g., `details = list(factorial = 'fractional', FrF2args = list(nruns = 4, nfactors = 3, ncenter = 3))`. 

# Functionality shared with **secr** {#methods}

Methods for 'ipsecr' of generic functions defined in **secr**

| Function | Description |
|----------|-------------|
|makeNewData| generate dataframe suitable for `predict.ipsecr` |
|region.N| estimate number of animals in mask or polygon |

Methods for 'ipsecr' of generic functions from base R

| Function | Description |
|----------|-------------|
| coef    | coefficients (beta parameters) of fitted model |
| plot    | plot detection function from fitted model |
| print   | display 'ipsecr' object|
| predict | predict real parameters |
| summary | summarise fitted model|
| vcov    | variance-covariance matrix of coefficients (beta parameters) |

Functions from **secr** that work on fitted 'ipsecr' objects as-is

| Function | Description |
|----------|-------------|
| ellipse.secr| plot confidence ellipse for 2 parameters |
| predictDsurface| predict density for each cell of mask |
| makeStart| generate starting values from various inputs |
| collate | tabulate results from multiple models |

# References

Borchers, D. L. and Efford, M. G. (2008) Spatially explicit maximum likelihood methods for capture--recapture studies. *Biometrics* **64**, 377--385.

Carothers, A. D. (1979) The effects of unequal catchability on Jolly--Seber estimates. *Biometrics* **29**, 79--100.

Distiller, G. and Borchers, D. L. (2015) A spatially explicit capture--recapture estimator for single-catch traps. *Ecology and Evolution* **5**, 5075--5087.

Efford, M. G. (2004) Density estimation in live-trapping studies. *Oikos* **106**, 598--610.

Efford, M. G. (2022). secr: Spatially explicit capture--recapture models. R package version
  4.5.4. https://CRAN.R-project.org/package=secr/

Efford, M. G., Dawson, D. K. and Robbins C. S. (2004) DENSITY: software
for analysing capture-recapture data from passive detector arrays.
*Animal Biodiversity and Conservation* **27**, 217--228.

Groemping, U. (2014). R Package FrF2 for Creating and Analyzing Fractional Factorial 2-Level Designs. *Journal of Statistical Software*, **56**, 1--56. https://www.jstatsoft.org/article/view/v056i01.

Pledger, S. and Efford, M. G. (1998)  Correction of bias due to heterogeneous capture probability in capture-recapture studies of open populations. *Biometrics* **54**, 888--898.

[secr-manual.pdf]: https://www.otago.ac.nz/density/pdfs/secr-manual.pdf
[secr-overview.pdf]: https://www.otago.ac.nz/density/pdfs/secr-overview.pdf
[secr-datainput.pdf]: https://www.otago.ac.nz/density/pdfs/secr-datainput.pdf
[secr-densitysurfaces.pdf]: https://www.otago.ac.nz/density/pdfs/secr-densitysurfaces.pdf
[secr-finitemixtures.pdf]: https://www.otago.ac.nz/density/pdfs/secr-finitemixtures.pdf
[secr-habitatmasks.pdf]: https://www.otago.ac.nz/density/pdfs/secr-habitatmasks.pdf
[secr-markresight.pdf]: https://www.otago.ac.nz/density/pdfs/secr-markresight.pdf
[secr-models.pdf]: https://www.otago.ac.nz/density/pdfs/secr-models.pdf
[secr-multisession.pdf]: https://www.otago.ac.nz/density/pdfs/secr-multisession.pdf
[secr-noneuclidean.pdf]: https://www.otago.ac.nz/density/pdfs/secr-noneuclidean.pdf
[secr-parameterisations.pdf]: https://www.otago.ac.nz/density/pdfs/secr-parameterisations.pdf
[secr-polygondetectors.pdf]: https://www.otago.ac.nz/density/pdfs/secr-polygondetectors.pdf
[secr-sound.pdf]: https://www.otago.ac.nz/density/pdfs/secr-sound.pdf
[secr-spatialdata.pdf]: https://www.otago.ac.nz/density/pdfs/secr-spatialdata.pdf
[secr-telemetry.pdf]: https://www.otago.ac.nz/density/pdfs/secr-telemetry.pdf
[secr-tutorial.pdf]: https://www.otago.ac.nz/density/pdfs/secr-tutorial.pdf
[secr-troubleshooting.pdf]: https://www.otago.ac.nz/density/pdfs/secr-troubleshooting.pdf
[secr-varyingeffort.pdf]: https://www.otago.ac.nz/density/pdfs/secr-varyingeffort.pdf

[secrdesign-vignette.pdf]: https://www.otago.ac.nz/density/pdfs/secrdesign-vignette.pdf
[secrlinear-vignette.pdf]: https://CRAN.R-project.org/package=secrlinear/vignettes/secrlinear-vignette.pdf

[secr-version4.pdf]: https://www.otago.ac.nz/density/pdfs/secr-version4.pdf

[phidot]: http://www.phidot.org/forum/
[secrgroup]: <https://groups.google.com/forum/#!forum/secrgroup>
[CRAN]: https://cran.r-project.org/package=secr